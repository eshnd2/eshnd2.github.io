Abstract
	Hardware, like IoT devices, are physical gadgets that can connect to both the internet and a tool to provide specific data. These machines are relatively inexpensive and applicable for many use cases, allowing them a large amount of potential to impact situations in developing countries and the field of data collection. However, one of the most substantial problems with these devices are small batteries or power usage limits and the exorbitant cost of more capable technology. In order to counter this issue, I have developed several strategies that optimize resource consumption in the client by applying algorithms and enhancements to the server and packet while applying only simple modifications to the client itself. Once the changes are implemented, systems using this improved protocol and server will be less expensive to maintain, which can lead to more usage of these devices to help increase food production, prevent disaster casualties, and gather data for environmental research.

Research Plan
I will attempt to improve current technology by building an application-layer protocol and programming library in C, implementing my enhancements, then publishing the protocol and library called “DRAALP” with an open-source license on Github. 
	There are three parts of the DRAALP system: the client, the server, and the script. The client is the object that collects data, the server is the object that receives data, and the script is the object that the server’s data is sent to. In this paper, it is assumed that the server and script are on the same machine, but when they are not, a second protocol must be used to transfer server data to the script, because the server usually doesn’t require energy optimization to this scale. The client is the part of this system that needs optimal efficiency.
DRAALP stands for “Data Retrieval/Analysis Application-Layer Protocol”, and it works by assuming that the client has a number of attributes, with each attribute having a value and index. The attributes are the data that will be sent via the internet. The order that these attributes are sent is constant, and cannot be changed unless the client-side code and server-side code are properly modified. 
Most of the improvements are on the server, meaning they will not increase the amount of power usage in the client, and any client-side modifications that are made will actively improve efficiency.
	The first planned server-side feature, Case Adaptability Process (CAP) is the most advanced. Using a clustering algorithm, it applies each attribute from the client as a factor and finds what values of certain factors correspond to other values of other factors. This process allows for multiple situations (or cases) to be created when each attribute is in a specific range.
	In the example below, there are two factors, labeled “one” and “two”. The “X”’s are the centroids where the euclidean distance from each of the points in their corresponding clusters is the least. You can find the case for any group by calculating the domain and range, for example, this is approximately the yellow group’s case: x x x x. 

Although we can only visualize this project up to 3 dimensions (meaning 3 attributes), the algorithm can theoretically scale to infinite attributes, and using PCA, a process to combine the original features linearly, we can maintain a maximum of 2 or 3 dimensions and receive similar quality of data with better efficiency.
	The CAP allows most situations to be cases, so that instead of sending a large amount of attributes, the client can send a single number in binary to the server, and accurate results (the centroid of the sent case) will be received by the server.
	Utilizing CAP, another feature can be created called Client-Side Standard Range. The server will determine what the most common case is, then it will find the range for each attribute, and will send the packet to the client. The client then uses a simple “if” loop for each attribute the next time it needs to send data, and if the data is within the standard range, the only data that needs to be sent is 1 bit, where a “1” means that it’s true. If the server receives a “0”, it will remain open to receive the correct case value, and if it receives a “0” for case value, it will remain open to receive an outlier value, which just provides the actual data for each attribute.
Again, utilizing CAP, another two features called Frequency Variation and QoS Modification can be made. They determine how frequently messages should be sent and what quality they should be sent with by checking case predictability and power usage. QoS, or Quality of Service can either be set to 0 or 1. If it is set to 0, the client will send data to the server, but will not know if it went through. If QoS is set to 1, the client will send data to the server and receive confirmation that it arrived, otherwise, it will retry the message. This uses slightly more power, and TCP, which DRAALP is built on, already has a similar system.
There are three packet types in DRAALP, the first one being the TC Packet (To Client) which includes all information about cases, standard range, frequency, and QoS configuring. How often TC Packets are sent is decided by the user, but if the current case and standard values are acceptable, the server can skip the TC send. The second packet type is a TS Packet (To Server), which is the packet containing either a 1 for standard range, the case value, or the outlier attribute values. The third packet type is the TCQ Packet (To Client Quality), which is a single binary value sent if QoS on the client is set to 1 and after a TS Packet is sent for confirmation. All packets will be encrypted, and the server will only connect the packet and the script if they have the same key (the amount of bits in a key is determined by how many scripts the server has).



All the code for the parts (client, server, and script) are built by the user using the library that I will program in C. The user will provide a few inputs via function calls: the attribute order, maximum value of the largest attribute, number of cases to be created (optional), how many cycles to wait between sending DRAALP TC Packets, how many scripts are used, initial frequency, and initial QoS.
